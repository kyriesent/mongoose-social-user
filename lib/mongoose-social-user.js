// Generated by CoffeeScript 1.3.3
(function() {
  var SocialReq, async;

  SocialReq = require('social-request');

  async = require('async');

  module.exports = function(schema, options) {
    var SocialUserData, SocialUserDataSchema, mongoose, socialReq, _findOrCreateUser;
    if ((options != null ? options.mongoose : void 0) == null) {
      throw new Error('No mongoose instance supplied, set options.mongoose in plugin definition');
    }
    mongoose = options.mongoose;
    SocialUserDataSchema = new mongoose.Schema({
      _user: {
        type: mongoose.Schema.Types.ObjectId,
        ref: options.userModel || 'User'
      },
      facebook: {
        userData: {},
        contacts: Array
      },
      twitter: {
        userData: {},
        contacts: Array
      },
      google: {
        userData: {},
        contacts: Array
      },
      googleplus: {
        userData: {},
        contacts: Array
      }
    });
    if (mongoose.models.SocialUserData) {
      SocialUserData = mongoose.models.SocialUserData;
    } else {
      SocialUserData = mongoose.model('SocialUserData', SocialUserDataSchema);
    }
    socialReq = new SocialReq();
    socialReq.use('google', {
      clientId: options.google.clientId,
      clientSecret: options.google.clientSecret
    }).use('googleplus', {
      clientId: options.google.clientId,
      clientSecret: options.google.clientSecret
    }).use('facebook', {
      appId: options.facebook.appId,
      appSecret: options.facebook.appSecret
    });
    schema.add({
      auth: {
        facebook: {
          id: String,
          username: String,
          aT: String,
          createdAt: Date
        },
        twitter: {
          id: String,
          username: String,
          aT: String,
          aTS: String,
          createdAt: Date
        },
        google: {
          id: String,
          username: String,
          aT: String,
          rT: String,
          createdAt: Date
        },
        googleplus: {
          id: String,
          username: String,
          aT: String,
          rT: String,
          createdAt: Date
        }
      }
    });
    _findOrCreateUser = function(params, done) {
      var self, upsertToDatabase;
      if (!params.service || !params.session || !params.data) {
        return done(new Error("couldn't log you in"));
      }
      self = this;
      return async.waterfall([
        function(cb) {
          var userFindParams, _ref, _ref1;
          userFindParams = {};
          userFindParams['auth.' + params.service + '.id'] = params.data.id;
          if (((_ref = params.session) != null ? (_ref1 = _ref.auth) != null ? _ref1.userId : void 0 : void 0) != null) {
            return async.parallel({
              user: function(cb) {
                return self.findById(params.session.auth.userId, cb);
              },
              occupyingUser: function(cb) {
                return self.findOne(userFindParams, cb);
              }
            }, function(err, results) {
              if (!(results.user != null)) {
                return cb(new Error('No user is linked to the user in the session. How is this person logged in?'));
              }
              if (results.occupyingUser && results.occupyingUser.id !== params.session.auth.userId) {
                return cb(new Error('Another user has already linked this account'));
              }
              return cb(err, results.user, false);
            });
          } else {
            return async.waterfall([
              function(cb) {
                return self.findOne(userFindParams, cb);
              }, function(user, cb) {
                if (user != null) {
                  return cb(null, user);
                }
                if (params.data.email == null) {
                  return cb(null, null);
                }
                return self.findOne({
                  'email': params.data.email
                }, function(err, user) {
                  return cb(err, (user != null ? user : null));
                });
              }, function(user, cb) {
                if (user != null) {
                  return cb(null, user, false);
                }
                return self.create({}, function(err, user) {
                  return cb(err, user, true);
                });
              }
            ], cb);
          }
        }, upsertToDatabase = function(user, newUser, cb) {
          return async.parallel({
            user: function(cb) {
              user.auth[params.service].id = params.data.id;
              user.auth[params.service].username = params.data.username;
              if (newUser) {
                user.auth[params.service].createdAt = new Date();
              }
              user.auth[params.service].aT = params.data.aT;
              if (params.data.rT != null) {
                user.auth[params.service].rT = params.data.rT;
              }
              if (params.data.aTS != null) {
                user.auth[params.service].aTS = params.data.aTS;
              }
              return user.save(cb);
            },
            socialUserData: function(cb) {
              return async.waterfall([
                function(cb) {
                  return SocialUserData.findOne({
                    _user: user._id
                  }, cb);
                }, function(socialUserData, cb) {
                  if (socialUserData != null) {
                    return cb(null, socialUserData);
                  }
                  return SocialUserData.create({
                    _user: user._id
                  }, function(err, socialUserData) {
                    return cb(null, socialUserData);
                  });
                }, function(socialUserData, cb) {
                  var param, _ref;
                  if (((_ref = socialUserData[params.service]) != null ? _ref.userData : void 0) == null) {
                    socialUserData[params.service].userData = params.data;
                  } else {
                    for (param in params.data) {
                      socialUserData[params.service].userData[param] = params.data[param];
                    }
                    socialUserData.markModified(params.service + '.userData');
                  }
                  return socialUserData.save(cb);
                }
              ], cb);
            }
          }, function(err, results) {
            return cb(null, user, newUser);
          });
        }
      ], done);
    };
    schema.statics.findOrCreateUser = function(service) {
      var self;
      self = this;
      switch (service) {
        case 'googlehybrid':
          return function(session, userAttributes) {
            var params, promise;
            promise = this.Promise();
            params = {
              service: "google",
              session: session,
              data: userAttributes
            };
            params.data.id = params.data.claimedIdentifier.split('=')[1];
            params.data.username = params.data.email;
            params.data.userData = {
              email: params.data.email,
              firstname: params.data.firstname,
              lastname: params.data.lastname
            };
            params.data.aT = params.data.access_token;
            params.data.aTS = params.data.access_token_secret;
            _findOrCreateUser.bind(self)(params, function(err, user, newUser) {
              if (err) {
                return promise.fulfill([err]);
              }
              session.newUser = newUser;
              session.authUserData = params.data;
              session.authUserData.service = params.service;
              return promise.fulfill(user);
            });
            return promise;
          };
        case 'google':
          return function(session, accessToken, accessTokExtra, userAttributes) {
            var params, promise;
            promise = this.Promise();
            params = {
              service: "google",
              session: session,
              data: userAttributes
            };
            params.data.username = params.data.email;
            params.data.aT = accessToken;
            if (accessTokExtra.refresh_token != null) {
              params.data.rT = accessTokExtra.refresh_token;
            }
            params.data.aTE = accessTokExtra;
            _findOrCreateUser.bind(self)(params, function(err, user, newUser) {
              if (err) {
                return promise.fulfill([err]);
              }
              session.newUser = newUser;
              session.authUserData = params.data;
              session.authUserData.service = params.service;
              return promise.fulfill(user);
            });
            return promise;
          };
        case 'facebook':
          return function(session, accessToken, accessTokExtra, fbUserMetaData) {
            var params, promise;
            promise = this.Promise();
            params = {
              service: "facebook",
              session: session,
              data: fbUserMetaData
            };
            params.data.aT = accessToken;
            params.data.aTE = accessTokExtra;
            _findOrCreateUser.bind(self)(params, function(err, user, newUser) {
              if (err) {
                return promise.fulfill([err]);
              }
              session.newUser = newUser;
              session.authUserData = params.data;
              session.authUserData.service = params.service;
              return promise.fulfill(user);
            });
            return promise;
          };
      }
    };
    schema.methods._socialReqGet = function(params, cb) {
      var self;
      self = this;
      socialReq.getTokens(function(id, cb) {
        return cb({
          facebook: {
            access_token: self.auth.facebook.aT
          },
          google: {
            access_token: self.auth.google.aT,
            refresh_token: self.auth.google.rT
          },
          googleplus: {
            access_token: self.auth.google.aT
          }
        });
      });
      return socialReq.get(this.id, params, cb);
    };
    schema.methods.getSocial = function(params, done) {
      var attemptSecondTriesIfNecessary, cacheSocialUserData, firstTry, getSocialUserData, processResults, self;
      self = this;
      return async.waterfall([
        firstTry = function(cb) {
          return self._socialReqGet(params, cb);
        }, attemptSecondTriesIfNecessary = function(results, cb) {
          var attemptSocialReq, firstTryHasFailures, mergeResults, requestType, secondTryServices, service, socialGetParams;
          firstTryHasFailures = false;
          secondTryServices = [];
          socialGetParams = {};
          for (requestType in results) {
            for (service in results[requestType]) {
              if (results[requestType][service].error != null) {
                firstTryHasFailures = true;
                if (secondTryServices.indexOf(service) === -1) {
                  secondTryServices.push(service);
                }
                if (socialGetParams[requestType] == null) {
                  socialGetParams[requestType] = [];
                }
                socialGetParams[requestType].push(service);
              }
            }
          }
          if (!firstTryHasFailures) {
            return cb(null, results);
          }
          return async.waterfall([
            function(cb) {
              var attemptToRefreshAccessToken, removeServiceFromSocialGetParams;
              removeServiceFromSocialGetParams = function(service) {
                var i, _results;
                _results = [];
                for (requestType in socialGetParams) {
                  i = socialGetParams[requestType].indexOf(service);
                  if (i !== -1) {
                    socialGetParams[requestType].splice(i, 1);
                  }
                  if (socialGetParams[requestType] === 0) {
                    _results.push(delete socialGetParams[requestType]);
                  } else {
                    _results.push(void 0);
                  }
                }
                return _results;
              };
              return async.forEach(secondTryServices, attemptToRefreshAccessToken = function(service, cb) {
                if (service === 'google' || service === 'googleplus') {
                  return self._refreshAccessToken('google', function(err, user) {
                    if (err != null) {
                      removeServiceFromSocialGetParams(service);
                    }
                    return cb();
                  });
                } else {
                  removeServiceFromSocialGetParams(service);
                  return cb();
                }
              }, cb);
            }, attemptSocialReq = function(cb) {
              if (Object.keys(socialGetParams).length === 0) {
                return cb();
              }
              return self._socialReqGet(socialGetParams, cb);
            }, mergeResults = function(secondResults, cb) {
              if (typeof secondResults === 'function') {
                return secondResults(null, results);
              }
              for (requestType in secondResults) {
                for (service in secondResults[requestType]) {
                  results[requestType][service] = secondResults[requestType][service];
                }
              }
              return cb(null, results);
            }
          ], cb);
        }, getSocialUserData = function(results, cb) {
          return async.waterfall([
            function(cb) {
              return SocialUserData.findOne({
                _user: self._id
              }, cb);
            }, function(socialUserData, cb) {
              if (socialUserData == null) {
                return SocialUserData.create({
                  _user: self._id
                }, cb);
              }
              return cb(null, socialUserData);
            }
          ], function(err, socialUserData) {
            return cb(err, results, socialUserData);
          });
        }, processResults = function(results, socialUserData, cb) {
          return async.parallel({
            processContacts: function(cb) {
              var processingFunctions;
              if (results.contacts == null) {
                return cb();
              }
              processingFunctions = [];
              Object.keys(results.contacts).forEach(function(service, i, keys) {
                if (results.contacts[service].error != null) {
                  return;
                }
                return processingFunctions.push(function(cb) {
                  return async.filter(results.contacts[service], function(contact, cb) {
                    if (service === 'google') {
                      return cb(contact.email != null);
                    }
                    return cb(true);
                  }, function(contacts) {
                    return async.sortBy(contacts, function(contact, cb) {
                      var _ref;
                      if (service === 'google') {
                        return cb(null, (_ref = contact.entry.gd$name) != null ? _ref.gd$familyName : void 0);
                      }
                      if (service === 'facebook') {
                        return cb(null, contact.name);
                      }
                      return cb(null, null);
                    }, function(err, contacts) {
                      if (err != null) {
                        done(err);
                      }
                      if (!socialUserData[service]) {
                        socialUserData[service] = {};
                      }
                      socialUserData[service].contacts = results.contacts[service] = JSON.stringify(contacts);
                      return cb();
                    });
                  });
                });
              });
              return async.parallel(processingFunctions, cb);
            },
            processDetails: function(cb) {
              if (results.details == null) {
                return cb();
              }
              Object.keys(results.details).forEach(function(service, i, keys) {
                var param;
                if (results.details[service].error != null) {
                  return;
                }
                if (socialUserData[service].userData == null) {
                  return socialUserData[service].userData = results.details[service];
                }
                for (param in results.details[service]) {
                  socialUserData[service].userData[param] = results.details[service][param];
                }
                return socialUserData.markModified(service + '.userData');
              });
              return cb();
            }
          }, function(err, processingResults) {
            return cb(err, results, socialUserData);
          });
        }, cacheSocialUserData = function(results, socialUserData, cb) {
          return async.parallel({
            user: function(cb) {
              return self.save(cb);
            },
            socialUserData: function(cb) {
              return socialUserData.save(cb);
            }
          }, function(err, models) {
            return cb(err, results);
          });
        }
      ], done);
    };
    /*
      schema.on 'init', (model) ->
        socialReq.getTokens (id, cb) ->
          model.findById id, (err, user) ->
            return cb(err || new Error 'User does not exist') if err? or not user?
            cb
              facebook:
                access_token: user.auth.facebook.aT
              google: 
                access_token: user.auth.google.aT
                access_token_secret: user.auth.google.aTS
    */

    schema.methods._invalidateAccessToken = function(service, done) {
      if (this.auth[service] == null) {
        return done(null, this);
      }
      this.auth[service].aT = void 0;
      this.auth[service].aTS = void 0;
      return this.save(done);
    };
    schema.methods._refreshAccessToken = function(service, done) {
      var self;
      if (this.auth[service] == null) {
        return done(null, this);
      }
      if (this.auth[service].rT == null) {
        return done({
          message: 'No refresh token for service ' + service + ', user needs to reauthenticate',
          code: 400
        });
      }
      self = this;
      socialReq.getTokens(function(id, cb) {
        return cb({
          facebook: {
            access_token: self.auth.facebook.aT
          },
          google: {
            access_token: self.auth.google.aT,
            refresh_token: self.auth.google.rT
          },
          googleplus: {
            access_token: self.auth.google.aT
          }
        });
      });
      return socialReq.get(this.id, {
        tokens: [service]
      }, function(err, results) {
        var _ref, _ref1;
        if (err != null) {
          return done(err);
        }
        if ((_ref = results.tokens[service]) != null ? _ref.error : void 0) {
          return done((_ref1 = results.tokens[service]) != null ? _ref1.error : void 0);
        }
        self.auth.google.aT = results.tokens[service].access_token;
        return self.save(done);
      });
    };
  };

}).call(this);
